'use strict'

const bufferEq = require('buffer-equal-constant-time')
const path = require('path')
const config = require(path.join(__dirname, '/../config'))
const crypto = require('crypto')

const gitFactory = require('../lib/GitServiceFactory')
const Staticman = require('../lib/Staticman')

/**
 * Express handler for webhook requests/notifications generated by the backing git service.
 */
module.exports = async (req, res, next) => {
  // Allow for multiple errors to be raised and reported back.
  let errorsRaised = []

  let service = req.params.service
  const version = req.params.version
  let staticman = null
  let configBranch = null
  // v1 of the webhook endpoint assumed GitHub.
  if (!service && version === '1') {
    service = 'github'
  } else {
    /*
     * In versions of the webhook endpoint beyond v1, we have the parameters necessary to
     * instantiate a Staticman instance right away.
     */
    service = req.params.service
    staticman = await new Staticman(req.params)
    staticman.setConfigPath()

    await staticman.getSiteConfig().then((siteConfig) => {
      configBranch = siteConfig.get('branch') || config.get('branch')
    }).catch((error) => {
      errorsRaised = errorsRaised.concat(error)
    })

    if (configBranch && (req.params.branch !== configBranch)) {
      console.log(`Branch check failed - configBranch = ${configBranch}, paramsBranch = ${req.params.branch}`)
      errorsRaised.push('Branch mismatch. Ignoring request.')
    }
  }

  if (errorsRaised.length === 0) {
    switch (service) {
      case 'github':
        await _handleWebhookGitHub(req, service, staticman, configBranch).catch((errors) => {
          errorsRaised = errorsRaised.concat(errors)
        })
        break
      case 'gitlab':
        await _handleWebhookGitLab(req, service, staticman, configBranch).catch((errors) => {
          errorsRaised = errorsRaised.concat(errors)
        })
        break
      default:
        errorsRaised.push('Unexpected service specified.')
    }
  }

  if (errorsRaised.length > 0) {
    res.status(400).send({
      errors: JSON.stringify(errorsRaised)
    })
  } else {
    res.status(200).send({
      success: true
    })
  }
}

const _handleWebhookGitHub = async function (req, service, staticman, configBranch) {
  let errorsRaised = []

  const event = req.headers['x-github-event']
  if (!event) {
    errorsRaised.push('No event found in the request')
  } else {
    if (event === 'pull_request') {
      let webhookSecretExpected = null
      if (staticman) {
        // Webhook request authentication is NOT supported in v1 of the endpoint.
        await staticman.getSiteConfig().then((siteConfig) => {
          webhookSecretExpected = siteConfig.get('githubWebhookSecret') || config.get('githubWebhookSecret')
        })
      }

      let reqAuthenticated = true
      if (webhookSecretExpected) {
        reqAuthenticated = false
        const webhookSecretSent = req.headers['x-hub-signature']
        if (!webhookSecretSent) {
          // This could be worth logging... unless the endpoint gets hammered with spam.
          errorsRaised.push('No secret found in the webhook request')
        } else if (_verifyGitHubSignature(webhookSecretExpected, JSON.stringify(req.body), webhookSecretSent)) {
          reqAuthenticated = true
        } else {
          // This could be worth logging... unless the endpoint gets hammered with spam.
          errorsRaised.push('Unable to verify authenticity of request')
        }
      }

      if (reqAuthenticated) {
        await _handleMergeRequest(req.params, service, req.body, staticman, configBranch).catch((errors) => {
          errorsRaised = errors
        })
      }
    }
  }

  if (errorsRaised.length > 0) {
    return Promise.reject(errorsRaised)
  }
}

const _handleWebhookGitLab = async function (req, service, staticman, configBranch) {
  let errorsRaised = []

  const event = req.headers['x-gitlab-event']
  if (!event) {
    errorsRaised.push('No event found in the request')
  } else {
    if (event === 'Merge Request Hook') {
      let webhookSecretExpected = null
      if (staticman) {
        // Webhook request authentication is NOT supported in v1 of the endpoint.
        await staticman.getSiteConfig().then((siteConfig) => {
          webhookSecretExpected = siteConfig.get('gitlabWebhookSecret') || config.get('gitlabWebhookSecret')
        })
      }

      let reqAuthenticated = true
      if (webhookSecretExpected) {
        reqAuthenticated = false
        const webhookSecretSent = req.headers['x-gitlab-token']
        if (!webhookSecretSent) {
          // This could be worth logging... unless the endpoint gets hammered with spam.
          errorsRaised.push('No secret found in the webhook request')
        } else if (webhookSecretExpected === webhookSecretSent) {
          /*
           * Whereas GitHub uses the webhook secret to sign the request body, GitLab does not.
           * As such, just check that the received secret equals the expected value.
           */
          reqAuthenticated = true
        } else {
          // This could be worth logging... unless the endpoint gets hammered with spam.
          errorsRaised.push('Unable to verify authenticity of request')
        }
      }

      if (reqAuthenticated) {
        await _handleMergeRequest(req.params, service, req.body, staticman, configBranch).catch((errors) => {
          errorsRaised = errors
        })
      }
    }
  }

  if (errorsRaised.length > 0) {
    return Promise.reject(errorsRaised)
  }
}

const _verifyGitHubSignature = function (secret, data, signature) {
  const signedData = 'sha1=' + crypto.createHmac('sha1', secret).update(data).digest('hex')
  return bufferEq(Buffer.from(signature), Buffer.from(signedData))
}

const _handleMergeRequest = async function (params, service, data, staticman, configBranch) {
  // Allow for multiple errors to be raised and reported back.
  const errors = []

  const ua = config.get('analytics.uaTrackingId')
    ? require('universal-analytics')(config.get('analytics.uaTrackingId'))
    : null

  let mergeReqNbr = null
  let webhookBranch = null
  if (service === 'github') {
    webhookBranch = data.pull_request.base.ref
    mergeReqNbr = data.number
  } else if (service === 'gitlab') {
    webhookBranch = data.object_attributes.target_branch
    mergeReqNbr = data.object_attributes.iid
  } else {
    errors.push('Unable to determine service.')
    return Promise.reject(errors)
  }

  if (mergeReqNbr === null || typeof mergeReqNbr === 'undefined') {
    errors.push('No pull/merge request number found.')
    return Promise.reject(errors)
  }

  const gitService = await _buildGitService(params, service, data, configBranch, webhookBranch).catch((error) => {
    errors.push(error)
    return Promise.reject(errors)
  })

  let review = await gitService.getReview(mergeReqNbr).catch((error) => {
    const msg = `Failed to retrieve merge request ${mergeReqNbr} - ${error}`
    console.error(msg)
    errors.push(msg)
    return Promise.reject(errors)
  })
  // console.log('review = %o', review)

  /*
   * We might receive "real" (non-bot) pull requests for files other than Staticman-processed
   * comments. Ignore these by filtering on Staticman-created merge request branches.
   */
  if (review.sourceBranch.indexOf('staticman_') > -1) {
    /*
     * Note that the review state is derived from the call to the git service, NOT the webhook
     * payload. And merged requests are represented with different states in each (at least in
     * GitHub). Tricky.
     *
     * We'll regularly receive webhook calls whenever a pull/merge request is opened, not just
     * merged/closed.
     */
    if (review.state === 'merged' || review.state === 'closed') {
      await _createNotifyMailingList(review, staticman, ua).catch((error) => {
        errors.push(error.message)
      })

      /*
       * Deleting the merge request branch is only necessary for GitHub, as GitLab automatically
       * deletes it upon merging.
       */
      if (service === 'github') {
        await _deleteMergeRequestBranch(gitService, review, ua).catch((error) => {
          errors.push(error)
        })
      }
    }
  }

  if (errors.length > 0) {
    return Promise.reject(errors)
  }
}

const _buildGitService = async function (params, service, data, configBranch, webhookBranch) {
  const version = params.version
  let username = params.username
  let repository = params.repository
  let branch = params.branch

  if (service === 'github') {
    /*
     * In v1 of the endpoint, the service, username, repository, and branch parameters were
     * omitted. As such, if not provided in the webhook request URL, pull them from the webhook
     * payload.
     */
    if (username === null || typeof username === 'undefined') {
      username = data.repository.owner.login
    }
    if (repository === null || typeof repository === 'undefined') {
      repository = data.repository.name
    }
    if (branch === null || typeof branch === 'undefined') {
      branch = data.pull_request.base.ref
    }
  }

  let gitService = null
  /*
   * A merge request processed (i.e., opened, merged, closed) against one branch in a repository
   * will trigger ALL webhooks triggered by merge request events in that repository. Meaning,
   * the webhook controller running in a (for example) prod Staticman instance will receive
   * webhook calls triggered by merge request events against a (for example) dev branch. As such,
   * we should expect plenty of extraneous webhook requests. The critical criterion is the branch
   * in the webhook payload matching the branch specified in the configuration.
   */
  if ((configBranch && (configBranch !== webhookBranch)) || branch !== webhookBranch) {
    console.log(`Merge branch mismatch - configBranch = ${configBranch}, webhookBranch = ${webhookBranch}, paramsBranch = ${branch}`)
    return Promise.reject(new Error('Merge branch mismatch. Ignoring request.'))
  } else {
    gitService = await gitFactory.create(service, {
      version: version,
      username: username,
      repository: repository,
      branch: branch
    })
  }

  return gitService
}

const _createNotifyMailingList = async function (review, staticman, ua) {
  /*
   * The "staticman_notification" comment section of the pull/merge request comment only
   * exists if notifications were enabled at the time the pull/merge request was created.
   */
  const bodyMatch = review.body.match(/(?:.*?)<!--staticman_notification:(.+?)-->(?:.*?)/i)
  if (bodyMatch && (bodyMatch.length === 2)) {
    try {
      const parsedBody = JSON.parse(bodyMatch[1])
      if (staticman === null) {
        staticman = await new Staticman(parsedBody.parameters)
        staticman.setConfigPath(parsedBody.configPath)
      }

      await staticman.processMerge(parsedBody.fields, parsedBody.extendedFields, parsedBody.options).then(msg => {
        if (ua) {
          ua.event('Hooks', 'Create/notify mailing list').send()
        }
      })
    } catch (err) {
      if (ua) {
        ua.event('Hooks', 'Create/notify mailing list error').send()
      }

      return Promise.reject(err)
    }
  }
}

const _deleteMergeRequestBranch = async function (gitService, review, ua) {
  try {
    // This will throw the error 'Reference does not exist' if the branch has already been deleted.
    await gitService.deleteBranch(review.sourceBranch)
    if (ua) {
      ua.event('Hooks', 'Delete branch').send()
    }
  } catch (err) {
    if (ua) {
      ua.event('Hooks', 'Delete branch error').send()
    }

    const msg = `Failed to delete merge branch ${review.sourceBranch} - ${err}`
    console.error(msg)
    return Promise.reject(msg)
  }
}
